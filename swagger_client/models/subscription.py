# coding: utf-8

"""
    Reepay Checkout API

    Reepay Checkout REST API  # noqa: E501

    OpenAPI spec version: 1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class Subscription(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'handle': 'str',
        'customer': 'str',
        'plan': 'str',
        'state': 'str',
        'test': 'bool',
        'amount': 'int',
        'quantity': 'int',
        'expires': 'datetime',
        'reactivated': 'datetime',
        'timezone': 'str',
        'created': 'datetime',
        'activated': 'datetime',
        'renewing': 'bool',
        'plan_version': 'int',
        'amount_incl_vat': 'bool',
        'start_date': 'datetime',
        'end_date': 'datetime',
        'grace_duration': 'int',
        'current_period_start': 'datetime',
        'next_period_start': 'datetime',
        'first_period_start': 'datetime',
        'last_period_start': 'datetime',
        'trial_start': 'datetime',
        'trial_end': 'datetime',
        'is_cancelled': 'bool',
        'in_trial': 'bool',
        'has_started': 'bool',
        'renewal_count': 'int',
        'cancelled_date': 'datetime',
        'expired_date': 'datetime',
        'expire_reason': 'str',
        'on_hold_date': 'datetime',
        'on_hold_reason': 'str',
        'payment_method_added': 'bool',
        'scheduled_plan_change': 'str',
        'reminder_email_sent': 'datetime',
        'failed_invoices': 'int',
        'failed_amount': 'int',
        'cancelled_invoices': 'int',
        'cancelled_amount': 'int',
        'pending_invoices': 'int',
        'pending_amount': 'int',
        'dunning_invoices': 'int',
        'dunning_amount': 'int',
        'settled_invoices': 'int',
        'settled_amount': 'int',
        'refunded_amount': 'int',
        'pending_additional_costs': 'int',
        'pending_additional_cost_amount': 'int',
        'transferred_additional_costs': 'int',
        'transferred_additional_cost_amount': 'int',
        'pending_credits': 'int',
        'pending_credit_amount': 'int',
        'transferred_credits': 'int',
        'transferred_credit_amount': 'int',
        'hosted_page_links': 'SubscriptionLinks',
        'subscription_discounts': 'list[str]',
        'pending_change': 'SubscriptionChange',
        'subscription_changes': 'list[SubscriptionChange]',
        'subscription_add_ons': 'list[str]'
    }

    attribute_map = {
        'handle': 'handle',
        'customer': 'customer',
        'plan': 'plan',
        'state': 'state',
        'test': 'test',
        'amount': 'amount',
        'quantity': 'quantity',
        'expires': 'expires',
        'reactivated': 'reactivated',
        'timezone': 'timezone',
        'created': 'created',
        'activated': 'activated',
        'renewing': 'renewing',
        'plan_version': 'plan_version',
        'amount_incl_vat': 'amount_incl_vat',
        'start_date': 'start_date',
        'end_date': 'end_date',
        'grace_duration': 'grace_duration',
        'current_period_start': 'current_period_start',
        'next_period_start': 'next_period_start',
        'first_period_start': 'first_period_start',
        'last_period_start': 'last_period_start',
        'trial_start': 'trial_start',
        'trial_end': 'trial_end',
        'is_cancelled': 'is_cancelled',
        'in_trial': 'in_trial',
        'has_started': 'has_started',
        'renewal_count': 'renewal_count',
        'cancelled_date': 'cancelled_date',
        'expired_date': 'expired_date',
        'expire_reason': 'expire_reason',
        'on_hold_date': 'on_hold_date',
        'on_hold_reason': 'on_hold_reason',
        'payment_method_added': 'payment_method_added',
        'scheduled_plan_change': 'scheduled_plan_change',
        'reminder_email_sent': 'reminder_email_sent',
        'failed_invoices': 'failed_invoices',
        'failed_amount': 'failed_amount',
        'cancelled_invoices': 'cancelled_invoices',
        'cancelled_amount': 'cancelled_amount',
        'pending_invoices': 'pending_invoices',
        'pending_amount': 'pending_amount',
        'dunning_invoices': 'dunning_invoices',
        'dunning_amount': 'dunning_amount',
        'settled_invoices': 'settled_invoices',
        'settled_amount': 'settled_amount',
        'refunded_amount': 'refunded_amount',
        'pending_additional_costs': 'pending_additional_costs',
        'pending_additional_cost_amount': 'pending_additional_cost_amount',
        'transferred_additional_costs': 'transferred_additional_costs',
        'transferred_additional_cost_amount': 'transferred_additional_cost_amount',
        'pending_credits': 'pending_credits',
        'pending_credit_amount': 'pending_credit_amount',
        'transferred_credits': 'transferred_credits',
        'transferred_credit_amount': 'transferred_credit_amount',
        'hosted_page_links': 'hosted_page_links',
        'subscription_discounts': 'subscription_discounts',
        'pending_change': 'pending_change',
        'subscription_changes': 'subscription_changes',
        'subscription_add_ons': 'subscription_add_ons'
    }

    def __init__(self, handle=None, customer=None, plan=None, state=None, test=None, amount=None, quantity=None, expires=None, reactivated=None, timezone=None, created=None, activated=None, renewing=None, plan_version=None, amount_incl_vat=None, start_date=None, end_date=None, grace_duration=None, current_period_start=None, next_period_start=None, first_period_start=None, last_period_start=None, trial_start=None, trial_end=None, is_cancelled=None, in_trial=None, has_started=None, renewal_count=None, cancelled_date=None, expired_date=None, expire_reason=None, on_hold_date=None, on_hold_reason=None, payment_method_added=None, scheduled_plan_change=None, reminder_email_sent=None, failed_invoices=None, failed_amount=None, cancelled_invoices=None, cancelled_amount=None, pending_invoices=None, pending_amount=None, dunning_invoices=None, dunning_amount=None, settled_invoices=None, settled_amount=None, refunded_amount=None, pending_additional_costs=None, pending_additional_cost_amount=None, transferred_additional_costs=None, transferred_additional_cost_amount=None, pending_credits=None, pending_credit_amount=None, transferred_credits=None, transferred_credit_amount=None, hosted_page_links=None, subscription_discounts=None, pending_change=None, subscription_changes=None, subscription_add_ons=None):  # noqa: E501
        """Subscription - a model defined in Swagger"""  # noqa: E501

        self._handle = None
        self._customer = None
        self._plan = None
        self._state = None
        self._test = None
        self._amount = None
        self._quantity = None
        self._expires = None
        self._reactivated = None
        self._timezone = None
        self._created = None
        self._activated = None
        self._renewing = None
        self._plan_version = None
        self._amount_incl_vat = None
        self._start_date = None
        self._end_date = None
        self._grace_duration = None
        self._current_period_start = None
        self._next_period_start = None
        self._first_period_start = None
        self._last_period_start = None
        self._trial_start = None
        self._trial_end = None
        self._is_cancelled = None
        self._in_trial = None
        self._has_started = None
        self._renewal_count = None
        self._cancelled_date = None
        self._expired_date = None
        self._expire_reason = None
        self._on_hold_date = None
        self._on_hold_reason = None
        self._payment_method_added = None
        self._scheduled_plan_change = None
        self._reminder_email_sent = None
        self._failed_invoices = None
        self._failed_amount = None
        self._cancelled_invoices = None
        self._cancelled_amount = None
        self._pending_invoices = None
        self._pending_amount = None
        self._dunning_invoices = None
        self._dunning_amount = None
        self._settled_invoices = None
        self._settled_amount = None
        self._refunded_amount = None
        self._pending_additional_costs = None
        self._pending_additional_cost_amount = None
        self._transferred_additional_costs = None
        self._transferred_additional_cost_amount = None
        self._pending_credits = None
        self._pending_credit_amount = None
        self._transferred_credits = None
        self._transferred_credit_amount = None
        self._hosted_page_links = None
        self._subscription_discounts = None
        self._pending_change = None
        self._subscription_changes = None
        self._subscription_add_ons = None
        self.discriminator = None

        self.handle = handle
        self.customer = customer
        self.plan = plan
        self.state = state
        self.test = test
        if amount is not None:
            self.amount = amount
        self.quantity = quantity
        if expires is not None:
            self.expires = expires
        if reactivated is not None:
            self.reactivated = reactivated
        self.timezone = timezone
        self.created = created
        if activated is not None:
            self.activated = activated
        self.renewing = renewing
        self.plan_version = plan_version
        if amount_incl_vat is not None:
            self.amount_incl_vat = amount_incl_vat
        self.start_date = start_date
        if end_date is not None:
            self.end_date = end_date
        if grace_duration is not None:
            self.grace_duration = grace_duration
        if current_period_start is not None:
            self.current_period_start = current_period_start
        if next_period_start is not None:
            self.next_period_start = next_period_start
        if first_period_start is not None:
            self.first_period_start = first_period_start
        if last_period_start is not None:
            self.last_period_start = last_period_start
        if trial_start is not None:
            self.trial_start = trial_start
        if trial_end is not None:
            self.trial_end = trial_end
        self.is_cancelled = is_cancelled
        self.in_trial = in_trial
        self.has_started = has_started
        self.renewal_count = renewal_count
        if cancelled_date is not None:
            self.cancelled_date = cancelled_date
        if expired_date is not None:
            self.expired_date = expired_date
        if expire_reason is not None:
            self.expire_reason = expire_reason
        if on_hold_date is not None:
            self.on_hold_date = on_hold_date
        if on_hold_reason is not None:
            self.on_hold_reason = on_hold_reason
        self.payment_method_added = payment_method_added
        if scheduled_plan_change is not None:
            self.scheduled_plan_change = scheduled_plan_change
        self.reminder_email_sent = reminder_email_sent
        self.failed_invoices = failed_invoices
        self.failed_amount = failed_amount
        self.cancelled_invoices = cancelled_invoices
        self.cancelled_amount = cancelled_amount
        self.pending_invoices = pending_invoices
        self.pending_amount = pending_amount
        self.dunning_invoices = dunning_invoices
        self.dunning_amount = dunning_amount
        self.settled_invoices = settled_invoices
        self.settled_amount = settled_amount
        self.refunded_amount = refunded_amount
        self.pending_additional_costs = pending_additional_costs
        self.pending_additional_cost_amount = pending_additional_cost_amount
        self.transferred_additional_costs = transferred_additional_costs
        self.transferred_additional_cost_amount = transferred_additional_cost_amount
        self.pending_credits = pending_credits
        self.pending_credit_amount = pending_credit_amount
        self.transferred_credits = transferred_credits
        self.transferred_credit_amount = transferred_credit_amount
        self.hosted_page_links = hosted_page_links
        if subscription_discounts is not None:
            self.subscription_discounts = subscription_discounts
        if pending_change is not None:
            self.pending_change = pending_change
        if subscription_changes is not None:
            self.subscription_changes = subscription_changes
        if subscription_add_ons is not None:
            self.subscription_add_ons = subscription_add_ons

    @property
    def handle(self):
        """Gets the handle of this Subscription.  # noqa: E501

        Per account unique handle for subscription  # noqa: E501

        :return: The handle of this Subscription.  # noqa: E501
        :rtype: str
        """
        return self._handle

    @handle.setter
    def handle(self, handle):
        """Sets the handle of this Subscription.

        Per account unique handle for subscription  # noqa: E501

        :param handle: The handle of this Subscription.  # noqa: E501
        :type: str
        """
        if handle is None:
            raise ValueError("Invalid value for `handle`, must not be `None`")  # noqa: E501

        self._handle = handle

    @property
    def customer(self):
        """Gets the customer of this Subscription.  # noqa: E501

        Customer handle  # noqa: E501

        :return: The customer of this Subscription.  # noqa: E501
        :rtype: str
        """
        return self._customer

    @customer.setter
    def customer(self, customer):
        """Sets the customer of this Subscription.

        Customer handle  # noqa: E501

        :param customer: The customer of this Subscription.  # noqa: E501
        :type: str
        """
        if customer is None:
            raise ValueError("Invalid value for `customer`, must not be `None`")  # noqa: E501

        self._customer = customer

    @property
    def plan(self):
        """Gets the plan of this Subscription.  # noqa: E501

        Subscription plan handle  # noqa: E501

        :return: The plan of this Subscription.  # noqa: E501
        :rtype: str
        """
        return self._plan

    @plan.setter
    def plan(self, plan):
        """Sets the plan of this Subscription.

        Subscription plan handle  # noqa: E501

        :param plan: The plan of this Subscription.  # noqa: E501
        :type: str
        """
        if plan is None:
            raise ValueError("Invalid value for `plan`, must not be `None`")  # noqa: E501

        self._plan = plan

    @property
    def state(self):
        """Gets the state of this Subscription.  # noqa: E501

        State of the subscription, one of the following: `active`, `expired`, `on_hold` or `pending`. Active subscriptions can be cancelled and will expire at the end of the current billing period, or later depending on optional notice and fixation periods, this can be checked using the `is_cancelled` parameter and `expires`.  # noqa: E501

        :return: The state of this Subscription.  # noqa: E501
        :rtype: str
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this Subscription.

        State of the subscription, one of the following: `active`, `expired`, `on_hold` or `pending`. Active subscriptions can be cancelled and will expire at the end of the current billing period, or later depending on optional notice and fixation periods, this can be checked using the `is_cancelled` parameter and `expires`.  # noqa: E501

        :param state: The state of this Subscription.  # noqa: E501
        :type: str
        """
        if state is None:
            raise ValueError("Invalid value for `state`, must not be `None`")  # noqa: E501
        allowed_values = ["active", "expired", "on_hold", "pending"]  # noqa: E501
        if state not in allowed_values:
            raise ValueError(
                "Invalid value for `state` ({0}), must be one of {1}"  # noqa: E501
                .format(state, allowed_values)
            )

        self._state = state

    @property
    def test(self):
        """Gets the test of this Subscription.  # noqa: E501

        Test flag  # noqa: E501

        :return: The test of this Subscription.  # noqa: E501
        :rtype: bool
        """
        return self._test

    @test.setter
    def test(self, test):
        """Sets the test of this Subscription.

        Test flag  # noqa: E501

        :param test: The test of this Subscription.  # noqa: E501
        :type: bool
        """
        if test is None:
            raise ValueError("Invalid value for `test`, must not be `None`")  # noqa: E501

        self._test = test

    @property
    def amount(self):
        """Gets the amount of this Subscription.  # noqa: E501

        Optional custom plan price. If defined the plan price billed for each billing period will be overridden by this price.  # noqa: E501

        :return: The amount of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._amount

    @amount.setter
    def amount(self, amount):
        """Sets the amount of this Subscription.

        Optional custom plan price. If defined the plan price billed for each billing period will be overridden by this price.  # noqa: E501

        :param amount: The amount of this Subscription.  # noqa: E501
        :type: int
        """

        self._amount = amount

    @property
    def quantity(self):
        """Gets the quantity of this Subscription.  # noqa: E501

        Quantity of the plan product for this subscription.  # noqa: E501

        :return: The quantity of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._quantity

    @quantity.setter
    def quantity(self, quantity):
        """Sets the quantity of this Subscription.

        Quantity of the plan product for this subscription.  # noqa: E501

        :param quantity: The quantity of this Subscription.  # noqa: E501
        :type: int
        """
        if quantity is None:
            raise ValueError("Invalid value for `quantity`, must not be `None`")  # noqa: E501

        self._quantity = quantity

    @property
    def expires(self):
        """Gets the expires of this Subscription.  # noqa: E501

        Fixed date when the subscription will expire because of cancellation. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The expires of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._expires

    @expires.setter
    def expires(self, expires):
        """Sets the expires of this Subscription.

        Fixed date when the subscription will expire because of cancellation. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param expires: The expires of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._expires = expires

    @property
    def reactivated(self):
        """Gets the reactivated of this Subscription.  # noqa: E501

        Date when the subscription was reactivated from on hold. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The reactivated of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._reactivated

    @reactivated.setter
    def reactivated(self, reactivated):
        """Sets the reactivated of this Subscription.

        Date when the subscription was reactivated from on hold. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param reactivated: The reactivated of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._reactivated = reactivated

    @property
    def timezone(self):
        """Gets the timezone of this Subscription.  # noqa: E501

        Time zone for the subscription as standard time zone id. See [Wikipedia](http://en.wikipedia.org/wiki/List_of_tz_database_time_zones)  # noqa: E501

        :return: The timezone of this Subscription.  # noqa: E501
        :rtype: str
        """
        return self._timezone

    @timezone.setter
    def timezone(self, timezone):
        """Sets the timezone of this Subscription.

        Time zone for the subscription as standard time zone id. See [Wikipedia](http://en.wikipedia.org/wiki/List_of_tz_database_time_zones)  # noqa: E501

        :param timezone: The timezone of this Subscription.  # noqa: E501
        :type: str
        """
        if timezone is None:
            raise ValueError("Invalid value for `timezone`, must not be `None`")  # noqa: E501

        self._timezone = timezone

    @property
    def created(self):
        """Gets the created of this Subscription.  # noqa: E501

        Date when the subscription was created. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The created of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._created

    @created.setter
    def created(self, created):
        """Sets the created of this Subscription.

        Date when the subscription was created. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param created: The created of this Subscription.  # noqa: E501
        :type: datetime
        """
        if created is None:
            raise ValueError("Invalid value for `created`, must not be `None`")  # noqa: E501

        self._created = created

    @property
    def activated(self):
        """Gets the activated of this Subscription.  # noqa: E501

        Date when the subscription was activated. Will only differ from created in a two step prepared -> activated subscription create scenario. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The activated of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._activated

    @activated.setter
    def activated(self, activated):
        """Sets the activated of this Subscription.

        Date when the subscription was activated. Will only differ from created in a two step prepared -> activated subscription create scenario. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param activated: The activated of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._activated = activated

    @property
    def renewing(self):
        """Gets the renewing of this Subscription.  # noqa: E501

        If the subscription renews at current period end. Also true for subscriptions with manual scheduling.  # noqa: E501

        :return: The renewing of this Subscription.  # noqa: E501
        :rtype: bool
        """
        return self._renewing

    @renewing.setter
    def renewing(self, renewing):
        """Sets the renewing of this Subscription.

        If the subscription renews at current period end. Also true for subscriptions with manual scheduling.  # noqa: E501

        :param renewing: The renewing of this Subscription.  # noqa: E501
        :type: bool
        """
        if renewing is None:
            raise ValueError("Invalid value for `renewing`, must not be `None`")  # noqa: E501

        self._renewing = renewing

    @property
    def plan_version(self):
        """Gets the plan_version of this Subscription.  # noqa: E501

        Subscription plan version  # noqa: E501

        :return: The plan_version of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._plan_version

    @plan_version.setter
    def plan_version(self, plan_version):
        """Sets the plan_version of this Subscription.

        Subscription plan version  # noqa: E501

        :param plan_version: The plan_version of this Subscription.  # noqa: E501
        :type: int
        """
        if plan_version is None:
            raise ValueError("Invalid value for `plan_version`, must not be `None`")  # noqa: E501

        self._plan_version = plan_version

    @property
    def amount_incl_vat(self):
        """Gets the amount_incl_vat of this Subscription.  # noqa: E501

        If optional custom plan price this parameter tells whether the amount is including VAT  # noqa: E501

        :return: The amount_incl_vat of this Subscription.  # noqa: E501
        :rtype: bool
        """
        return self._amount_incl_vat

    @amount_incl_vat.setter
    def amount_incl_vat(self, amount_incl_vat):
        """Sets the amount_incl_vat of this Subscription.

        If optional custom plan price this parameter tells whether the amount is including VAT  # noqa: E501

        :param amount_incl_vat: The amount_incl_vat of this Subscription.  # noqa: E501
        :type: bool
        """

        self._amount_incl_vat = amount_incl_vat

    @property
    def start_date(self):
        """Gets the start_date of this Subscription.  # noqa: E501

        Date and time from which the subscription is eligible to schedule invoices. Either from create or from the latest reactivate or subscription change. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The start_date of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._start_date

    @start_date.setter
    def start_date(self, start_date):
        """Sets the start_date of this Subscription.

        Date and time from which the subscription is eligible to schedule invoices. Either from create or from the latest reactivate or subscription change. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param start_date: The start_date of this Subscription.  # noqa: E501
        :type: datetime
        """
        if start_date is None:
            raise ValueError("Invalid value for `start_date`, must not be `None`")  # noqa: E501

        self._start_date = start_date

    @property
    def end_date(self):
        """Gets the end_date of this Subscription.  # noqa: E501

        Fixed end date and time. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The end_date of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._end_date

    @end_date.setter
    def end_date(self, end_date):
        """Sets the end_date of this Subscription.

        Fixed end date and time. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param end_date: The end_date of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._end_date = end_date

    @property
    def grace_duration(self):
        """Gets the grace_duration of this Subscription.  # noqa: E501

        Grace duration in seconds from the creation of a subscription where no dunning process is started for a failing invoice. This allows a certain amount of time for the customer to sign up with a payment method.  # noqa: E501

        :return: The grace_duration of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._grace_duration

    @grace_duration.setter
    def grace_duration(self, grace_duration):
        """Sets the grace_duration of this Subscription.

        Grace duration in seconds from the creation of a subscription where no dunning process is started for a failing invoice. This allows a certain amount of time for the customer to sign up with a payment method.  # noqa: E501

        :param grace_duration: The grace_duration of this Subscription.  # noqa: E501
        :type: int
        """

        self._grace_duration = grace_duration

    @property
    def current_period_start(self):
        """Gets the current_period_start of this Subscription.  # noqa: E501

        Start date and time for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The current_period_start of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._current_period_start

    @current_period_start.setter
    def current_period_start(self, current_period_start):
        """Sets the current_period_start of this Subscription.

        Start date and time for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param current_period_start: The current_period_start of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._current_period_start = current_period_start

    @property
    def next_period_start(self):
        """Gets the next_period_start of this Subscription.  # noqa: E501

        Start date and time for the next billing period, and also end date and time for the current billing period. Is also the date and time for next invoice if the subscription is renewing. In ISO-8601 extended offset date-time format.  # noqa: E501

        :return: The next_period_start of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._next_period_start

    @next_period_start.setter
    def next_period_start(self, next_period_start):
        """Sets the next_period_start of this Subscription.

        Start date and time for the next billing period, and also end date and time for the current billing period. Is also the date and time for next invoice if the subscription is renewing. In ISO-8601 extended offset date-time format.  # noqa: E501

        :param next_period_start: The next_period_start of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._next_period_start = next_period_start

    @property
    def first_period_start(self):
        """Gets the first_period_start of this Subscription.  # noqa: E501

        Start date and time for the first ever billing period. In ISO-8601 extended offset date-time format.  # noqa: E501

        :return: The first_period_start of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._first_period_start

    @first_period_start.setter
    def first_period_start(self, first_period_start):
        """Sets the first_period_start of this Subscription.

        Start date and time for the first ever billing period. In ISO-8601 extended offset date-time format.  # noqa: E501

        :param first_period_start: The first_period_start of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._first_period_start = first_period_start

    @property
    def last_period_start(self):
        """Gets the last_period_start of this Subscription.  # noqa: E501

        Start date and time for the previous billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The last_period_start of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._last_period_start

    @last_period_start.setter
    def last_period_start(self, last_period_start):
        """Sets the last_period_start of this Subscription.

        Start date and time for the previous billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param last_period_start: The last_period_start of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._last_period_start = last_period_start

    @property
    def trial_start(self):
        """Gets the trial_start of this Subscription.  # noqa: E501

        Start date and time of free trial period. In ISO-8601 extended offset date-time format.  # noqa: E501

        :return: The trial_start of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._trial_start

    @trial_start.setter
    def trial_start(self, trial_start):
        """Sets the trial_start of this Subscription.

        Start date and time of free trial period. In ISO-8601 extended offset date-time format.  # noqa: E501

        :param trial_start: The trial_start of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._trial_start = trial_start

    @property
    def trial_end(self):
        """Gets the trial_end of this Subscription.  # noqa: E501

        End date and time of free trial period. In ISO-8601 extended offset date-time format.  # noqa: E501

        :return: The trial_end of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._trial_end

    @trial_end.setter
    def trial_end(self, trial_end):
        """Sets the trial_end of this Subscription.

        End date and time of free trial period. In ISO-8601 extended offset date-time format.  # noqa: E501

        :param trial_end: The trial_end of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._trial_end = trial_end

    @property
    def is_cancelled(self):
        """Gets the is_cancelled of this Subscription.  # noqa: E501

        Whether the subscription has been cancelled. Cancelled subscriptions will expire at the end of the current billing period.  # noqa: E501

        :return: The is_cancelled of this Subscription.  # noqa: E501
        :rtype: bool
        """
        return self._is_cancelled

    @is_cancelled.setter
    def is_cancelled(self, is_cancelled):
        """Sets the is_cancelled of this Subscription.

        Whether the subscription has been cancelled. Cancelled subscriptions will expire at the end of the current billing period.  # noqa: E501

        :param is_cancelled: The is_cancelled of this Subscription.  # noqa: E501
        :type: bool
        """
        if is_cancelled is None:
            raise ValueError("Invalid value for `is_cancelled`, must not be `None`")  # noqa: E501

        self._is_cancelled = is_cancelled

    @property
    def in_trial(self):
        """Gets the in_trial of this Subscription.  # noqa: E501

        Whether the susbcription is in its trial period. If subscription has not started (has_started), trial_start and trial_end can be used to determine if the subscription will have a trial period.  # noqa: E501

        :return: The in_trial of this Subscription.  # noqa: E501
        :rtype: bool
        """
        return self._in_trial

    @in_trial.setter
    def in_trial(self, in_trial):
        """Sets the in_trial of this Subscription.

        Whether the susbcription is in its trial period. If subscription has not started (has_started), trial_start and trial_end can be used to determine if the subscription will have a trial period.  # noqa: E501

        :param in_trial: The in_trial of this Subscription.  # noqa: E501
        :type: bool
        """
        if in_trial is None:
            raise ValueError("Invalid value for `in_trial`, must not be `None`")  # noqa: E501

        self._in_trial = in_trial

    @property
    def has_started(self):
        """Gets the has_started of this Subscription.  # noqa: E501

        If subscription has a later start date, this parameter tells if the subscription has started. Use this in connection with state to determine if a subscription is active.  # noqa: E501

        :return: The has_started of this Subscription.  # noqa: E501
        :rtype: bool
        """
        return self._has_started

    @has_started.setter
    def has_started(self, has_started):
        """Sets the has_started of this Subscription.

        If subscription has a later start date, this parameter tells if the subscription has started. Use this in connection with state to determine if a subscription is active.  # noqa: E501

        :param has_started: The has_started of this Subscription.  # noqa: E501
        :type: bool
        """
        if has_started is None:
            raise ValueError("Invalid value for `has_started`, must not be `None`")  # noqa: E501

        self._has_started = has_started

    @property
    def renewal_count(self):
        """Gets the renewal_count of this Subscription.  # noqa: E501

        Number of renewals for the subscription (number of invoices)  # noqa: E501

        :return: The renewal_count of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._renewal_count

    @renewal_count.setter
    def renewal_count(self, renewal_count):
        """Sets the renewal_count of this Subscription.

        Number of renewals for the subscription (number of invoices)  # noqa: E501

        :param renewal_count: The renewal_count of this Subscription.  # noqa: E501
        :type: int
        """
        if renewal_count is None:
            raise ValueError("Invalid value for `renewal_count`, must not be `None`")  # noqa: E501
        if renewal_count is not None and renewal_count < 0:  # noqa: E501
            raise ValueError("Invalid value for `renewal_count`, must be a value greater than or equal to `0`")  # noqa: E501

        self._renewal_count = renewal_count

    @property
    def cancelled_date(self):
        """Gets the cancelled_date of this Subscription.  # noqa: E501

        Date when the subscription was cancelled. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The cancelled_date of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._cancelled_date

    @cancelled_date.setter
    def cancelled_date(self, cancelled_date):
        """Sets the cancelled_date of this Subscription.

        Date when the subscription was cancelled. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param cancelled_date: The cancelled_date of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._cancelled_date = cancelled_date

    @property
    def expired_date(self):
        """Gets the expired_date of this Subscription.  # noqa: E501

        Date when the subscription expired. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The expired_date of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._expired_date

    @expired_date.setter
    def expired_date(self, expired_date):
        """Sets the expired_date of this Subscription.

        Date when the subscription expired. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param expired_date: The expired_date of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._expired_date = expired_date

    @property
    def expire_reason(self):
        """Gets the expire_reason of this Subscription.  # noqa: E501

        Reason for expire. Can be `ondemand`, `cancelled`, `dunning` or `fixed`   # noqa: E501

        :return: The expire_reason of this Subscription.  # noqa: E501
        :rtype: str
        """
        return self._expire_reason

    @expire_reason.setter
    def expire_reason(self, expire_reason):
        """Sets the expire_reason of this Subscription.

        Reason for expire. Can be `ondemand`, `cancelled`, `dunning` or `fixed`   # noqa: E501

        :param expire_reason: The expire_reason of this Subscription.  # noqa: E501
        :type: str
        """
        allowed_values = ["dunning", "cancelled", "ondemand", "fixed"]  # noqa: E501
        if expire_reason not in allowed_values:
            raise ValueError(
                "Invalid value for `expire_reason` ({0}), must be one of {1}"  # noqa: E501
                .format(expire_reason, allowed_values)
            )

        self._expire_reason = expire_reason

    @property
    def on_hold_date(self):
        """Gets the on_hold_date of this Subscription.  # noqa: E501

        Date when the subscription was put on hold. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The on_hold_date of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._on_hold_date

    @on_hold_date.setter
    def on_hold_date(self, on_hold_date):
        """Sets the on_hold_date of this Subscription.

        Date when the subscription was put on hold. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param on_hold_date: The on_hold_date of this Subscription.  # noqa: E501
        :type: datetime
        """

        self._on_hold_date = on_hold_date

    @property
    def on_hold_reason(self):
        """Gets the on_hold_reason of this Subscription.  # noqa: E501

        Reason for on hold. Can be `ondemand` or `dunning`   # noqa: E501

        :return: The on_hold_reason of this Subscription.  # noqa: E501
        :rtype: str
        """
        return self._on_hold_reason

    @on_hold_reason.setter
    def on_hold_reason(self, on_hold_reason):
        """Sets the on_hold_reason of this Subscription.

        Reason for on hold. Can be `ondemand` or `dunning`   # noqa: E501

        :param on_hold_reason: The on_hold_reason of this Subscription.  # noqa: E501
        :type: str
        """
        allowed_values = ["dunning", "ondemand"]  # noqa: E501
        if on_hold_reason not in allowed_values:
            raise ValueError(
                "Invalid value for `on_hold_reason` ({0}), must be one of {1}"  # noqa: E501
                .format(on_hold_reason, allowed_values)
            )

        self._on_hold_reason = on_hold_reason

    @property
    def payment_method_added(self):
        """Gets the payment_method_added of this Subscription.  # noqa: E501

        Whether the customer at some point has added payment information to the subscription  # noqa: E501

        :return: The payment_method_added of this Subscription.  # noqa: E501
        :rtype: bool
        """
        return self._payment_method_added

    @payment_method_added.setter
    def payment_method_added(self, payment_method_added):
        """Sets the payment_method_added of this Subscription.

        Whether the customer at some point has added payment information to the subscription  # noqa: E501

        :param payment_method_added: The payment_method_added of this Subscription.  # noqa: E501
        :type: bool
        """
        if payment_method_added is None:
            raise ValueError("Invalid value for `payment_method_added`, must not be `None`")  # noqa: E501

        self._payment_method_added = payment_method_added

    @property
    def scheduled_plan_change(self):
        """Gets the scheduled_plan_change of this Subscription.  # noqa: E501

        Deprecated - see `pending_change`. If set, a subscription plan change has been scheduled to follow the next renewal. The value is the subscription plan handle to update to.  # noqa: E501

        :return: The scheduled_plan_change of this Subscription.  # noqa: E501
        :rtype: str
        """
        return self._scheduled_plan_change

    @scheduled_plan_change.setter
    def scheduled_plan_change(self, scheduled_plan_change):
        """Sets the scheduled_plan_change of this Subscription.

        Deprecated - see `pending_change`. If set, a subscription plan change has been scheduled to follow the next renewal. The value is the subscription plan handle to update to.  # noqa: E501

        :param scheduled_plan_change: The scheduled_plan_change of this Subscription.  # noqa: E501
        :type: str
        """

        self._scheduled_plan_change = scheduled_plan_change

    @property
    def reminder_email_sent(self):
        """Gets the reminder_email_sent of this Subscription.  # noqa: E501

        If defined the date a reminder email was sent for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :return: The reminder_email_sent of this Subscription.  # noqa: E501
        :rtype: datetime
        """
        return self._reminder_email_sent

    @reminder_email_sent.setter
    def reminder_email_sent(self, reminder_email_sent):
        """Sets the reminder_email_sent of this Subscription.

        If defined the date a reminder email was sent for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.  # noqa: E501

        :param reminder_email_sent: The reminder_email_sent of this Subscription.  # noqa: E501
        :type: datetime
        """
        if reminder_email_sent is None:
            raise ValueError("Invalid value for `reminder_email_sent`, must not be `None`")  # noqa: E501

        self._reminder_email_sent = reminder_email_sent

    @property
    def failed_invoices(self):
        """Gets the failed_invoices of this Subscription.  # noqa: E501

        Number of failed invoices for this subscription  # noqa: E501

        :return: The failed_invoices of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._failed_invoices

    @failed_invoices.setter
    def failed_invoices(self, failed_invoices):
        """Sets the failed_invoices of this Subscription.

        Number of failed invoices for this subscription  # noqa: E501

        :param failed_invoices: The failed_invoices of this Subscription.  # noqa: E501
        :type: int
        """
        if failed_invoices is None:
            raise ValueError("Invalid value for `failed_invoices`, must not be `None`")  # noqa: E501

        self._failed_invoices = failed_invoices

    @property
    def failed_amount(self):
        """Gets the failed_amount of this Subscription.  # noqa: E501

        Summed amount for failed invoices  # noqa: E501

        :return: The failed_amount of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._failed_amount

    @failed_amount.setter
    def failed_amount(self, failed_amount):
        """Sets the failed_amount of this Subscription.

        Summed amount for failed invoices  # noqa: E501

        :param failed_amount: The failed_amount of this Subscription.  # noqa: E501
        :type: int
        """
        if failed_amount is None:
            raise ValueError("Invalid value for `failed_amount`, must not be `None`")  # noqa: E501

        self._failed_amount = failed_amount

    @property
    def cancelled_invoices(self):
        """Gets the cancelled_invoices of this Subscription.  # noqa: E501

        Number of cancelled invoices for this subscription  # noqa: E501

        :return: The cancelled_invoices of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._cancelled_invoices

    @cancelled_invoices.setter
    def cancelled_invoices(self, cancelled_invoices):
        """Sets the cancelled_invoices of this Subscription.

        Number of cancelled invoices for this subscription  # noqa: E501

        :param cancelled_invoices: The cancelled_invoices of this Subscription.  # noqa: E501
        :type: int
        """
        if cancelled_invoices is None:
            raise ValueError("Invalid value for `cancelled_invoices`, must not be `None`")  # noqa: E501

        self._cancelled_invoices = cancelled_invoices

    @property
    def cancelled_amount(self):
        """Gets the cancelled_amount of this Subscription.  # noqa: E501

        Summed amount for cancelled invoices  # noqa: E501

        :return: The cancelled_amount of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._cancelled_amount

    @cancelled_amount.setter
    def cancelled_amount(self, cancelled_amount):
        """Sets the cancelled_amount of this Subscription.

        Summed amount for cancelled invoices  # noqa: E501

        :param cancelled_amount: The cancelled_amount of this Subscription.  # noqa: E501
        :type: int
        """
        if cancelled_amount is None:
            raise ValueError("Invalid value for `cancelled_amount`, must not be `None`")  # noqa: E501

        self._cancelled_amount = cancelled_amount

    @property
    def pending_invoices(self):
        """Gets the pending_invoices of this Subscription.  # noqa: E501

        Number of pending invoices for this subscription  # noqa: E501

        :return: The pending_invoices of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._pending_invoices

    @pending_invoices.setter
    def pending_invoices(self, pending_invoices):
        """Sets the pending_invoices of this Subscription.

        Number of pending invoices for this subscription  # noqa: E501

        :param pending_invoices: The pending_invoices of this Subscription.  # noqa: E501
        :type: int
        """
        if pending_invoices is None:
            raise ValueError("Invalid value for `pending_invoices`, must not be `None`")  # noqa: E501

        self._pending_invoices = pending_invoices

    @property
    def pending_amount(self):
        """Gets the pending_amount of this Subscription.  # noqa: E501

        Summed amount for pending invoices  # noqa: E501

        :return: The pending_amount of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._pending_amount

    @pending_amount.setter
    def pending_amount(self, pending_amount):
        """Sets the pending_amount of this Subscription.

        Summed amount for pending invoices  # noqa: E501

        :param pending_amount: The pending_amount of this Subscription.  # noqa: E501
        :type: int
        """
        if pending_amount is None:
            raise ValueError("Invalid value for `pending_amount`, must not be `None`")  # noqa: E501

        self._pending_amount = pending_amount

    @property
    def dunning_invoices(self):
        """Gets the dunning_invoices of this Subscription.  # noqa: E501

        Number of dunning invoices for this subscription  # noqa: E501

        :return: The dunning_invoices of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._dunning_invoices

    @dunning_invoices.setter
    def dunning_invoices(self, dunning_invoices):
        """Sets the dunning_invoices of this Subscription.

        Number of dunning invoices for this subscription  # noqa: E501

        :param dunning_invoices: The dunning_invoices of this Subscription.  # noqa: E501
        :type: int
        """
        if dunning_invoices is None:
            raise ValueError("Invalid value for `dunning_invoices`, must not be `None`")  # noqa: E501

        self._dunning_invoices = dunning_invoices

    @property
    def dunning_amount(self):
        """Gets the dunning_amount of this Subscription.  # noqa: E501

        Summed amount for dunning invoices  # noqa: E501

        :return: The dunning_amount of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._dunning_amount

    @dunning_amount.setter
    def dunning_amount(self, dunning_amount):
        """Sets the dunning_amount of this Subscription.

        Summed amount for dunning invoices  # noqa: E501

        :param dunning_amount: The dunning_amount of this Subscription.  # noqa: E501
        :type: int
        """
        if dunning_amount is None:
            raise ValueError("Invalid value for `dunning_amount`, must not be `None`")  # noqa: E501

        self._dunning_amount = dunning_amount

    @property
    def settled_invoices(self):
        """Gets the settled_invoices of this Subscription.  # noqa: E501

        Number of settled invoices for this subscription  # noqa: E501

        :return: The settled_invoices of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._settled_invoices

    @settled_invoices.setter
    def settled_invoices(self, settled_invoices):
        """Sets the settled_invoices of this Subscription.

        Number of settled invoices for this subscription  # noqa: E501

        :param settled_invoices: The settled_invoices of this Subscription.  # noqa: E501
        :type: int
        """
        if settled_invoices is None:
            raise ValueError("Invalid value for `settled_invoices`, must not be `None`")  # noqa: E501

        self._settled_invoices = settled_invoices

    @property
    def settled_amount(self):
        """Gets the settled_amount of this Subscription.  # noqa: E501

        Summed settled amount  # noqa: E501

        :return: The settled_amount of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._settled_amount

    @settled_amount.setter
    def settled_amount(self, settled_amount):
        """Sets the settled_amount of this Subscription.

        Summed settled amount  # noqa: E501

        :param settled_amount: The settled_amount of this Subscription.  # noqa: E501
        :type: int
        """
        if settled_amount is None:
            raise ValueError("Invalid value for `settled_amount`, must not be `None`")  # noqa: E501

        self._settled_amount = settled_amount

    @property
    def refunded_amount(self):
        """Gets the refunded_amount of this Subscription.  # noqa: E501

        Summed refunded amount  # noqa: E501

        :return: The refunded_amount of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._refunded_amount

    @refunded_amount.setter
    def refunded_amount(self, refunded_amount):
        """Sets the refunded_amount of this Subscription.

        Summed refunded amount  # noqa: E501

        :param refunded_amount: The refunded_amount of this Subscription.  # noqa: E501
        :type: int
        """
        if refunded_amount is None:
            raise ValueError("Invalid value for `refunded_amount`, must not be `None`")  # noqa: E501

        self._refunded_amount = refunded_amount

    @property
    def pending_additional_costs(self):
        """Gets the pending_additional_costs of this Subscription.  # noqa: E501

        Number of pending additional costs  # noqa: E501

        :return: The pending_additional_costs of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._pending_additional_costs

    @pending_additional_costs.setter
    def pending_additional_costs(self, pending_additional_costs):
        """Sets the pending_additional_costs of this Subscription.

        Number of pending additional costs  # noqa: E501

        :param pending_additional_costs: The pending_additional_costs of this Subscription.  # noqa: E501
        :type: int
        """
        if pending_additional_costs is None:
            raise ValueError("Invalid value for `pending_additional_costs`, must not be `None`")  # noqa: E501

        self._pending_additional_costs = pending_additional_costs

    @property
    def pending_additional_cost_amount(self):
        """Gets the pending_additional_cost_amount of this Subscription.  # noqa: E501

        Summed amount of pending additional costs incl vat  # noqa: E501

        :return: The pending_additional_cost_amount of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._pending_additional_cost_amount

    @pending_additional_cost_amount.setter
    def pending_additional_cost_amount(self, pending_additional_cost_amount):
        """Sets the pending_additional_cost_amount of this Subscription.

        Summed amount of pending additional costs incl vat  # noqa: E501

        :param pending_additional_cost_amount: The pending_additional_cost_amount of this Subscription.  # noqa: E501
        :type: int
        """
        if pending_additional_cost_amount is None:
            raise ValueError("Invalid value for `pending_additional_cost_amount`, must not be `None`")  # noqa: E501

        self._pending_additional_cost_amount = pending_additional_cost_amount

    @property
    def transferred_additional_costs(self):
        """Gets the transferred_additional_costs of this Subscription.  # noqa: E501

        Number of additional costs that have been applied to invoices  # noqa: E501

        :return: The transferred_additional_costs of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._transferred_additional_costs

    @transferred_additional_costs.setter
    def transferred_additional_costs(self, transferred_additional_costs):
        """Sets the transferred_additional_costs of this Subscription.

        Number of additional costs that have been applied to invoices  # noqa: E501

        :param transferred_additional_costs: The transferred_additional_costs of this Subscription.  # noqa: E501
        :type: int
        """
        if transferred_additional_costs is None:
            raise ValueError("Invalid value for `transferred_additional_costs`, must not be `None`")  # noqa: E501

        self._transferred_additional_costs = transferred_additional_costs

    @property
    def transferred_additional_cost_amount(self):
        """Gets the transferred_additional_cost_amount of this Subscription.  # noqa: E501

        Summed amount of additional costs that have been applied to invoices  # noqa: E501

        :return: The transferred_additional_cost_amount of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._transferred_additional_cost_amount

    @transferred_additional_cost_amount.setter
    def transferred_additional_cost_amount(self, transferred_additional_cost_amount):
        """Sets the transferred_additional_cost_amount of this Subscription.

        Summed amount of additional costs that have been applied to invoices  # noqa: E501

        :param transferred_additional_cost_amount: The transferred_additional_cost_amount of this Subscription.  # noqa: E501
        :type: int
        """
        if transferred_additional_cost_amount is None:
            raise ValueError("Invalid value for `transferred_additional_cost_amount`, must not be `None`")  # noqa: E501

        self._transferred_additional_cost_amount = transferred_additional_cost_amount

    @property
    def pending_credits(self):
        """Gets the pending_credits of this Subscription.  # noqa: E501

        Number of credits that have not fully been applied to invoices  # noqa: E501

        :return: The pending_credits of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._pending_credits

    @pending_credits.setter
    def pending_credits(self, pending_credits):
        """Sets the pending_credits of this Subscription.

        Number of credits that have not fully been applied to invoices  # noqa: E501

        :param pending_credits: The pending_credits of this Subscription.  # noqa: E501
        :type: int
        """
        if pending_credits is None:
            raise ValueError("Invalid value for `pending_credits`, must not be `None`")  # noqa: E501

        self._pending_credits = pending_credits

    @property
    def pending_credit_amount(self):
        """Gets the pending_credit_amount of this Subscription.  # noqa: E501

        Summed credit amount not yet applied to invoices  # noqa: E501

        :return: The pending_credit_amount of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._pending_credit_amount

    @pending_credit_amount.setter
    def pending_credit_amount(self, pending_credit_amount):
        """Sets the pending_credit_amount of this Subscription.

        Summed credit amount not yet applied to invoices  # noqa: E501

        :param pending_credit_amount: The pending_credit_amount of this Subscription.  # noqa: E501
        :type: int
        """
        if pending_credit_amount is None:
            raise ValueError("Invalid value for `pending_credit_amount`, must not be `None`")  # noqa: E501

        self._pending_credit_amount = pending_credit_amount

    @property
    def transferred_credits(self):
        """Gets the transferred_credits of this Subscription.  # noqa: E501

        Number of credits that have fully been applied to invoices  # noqa: E501

        :return: The transferred_credits of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._transferred_credits

    @transferred_credits.setter
    def transferred_credits(self, transferred_credits):
        """Sets the transferred_credits of this Subscription.

        Number of credits that have fully been applied to invoices  # noqa: E501

        :param transferred_credits: The transferred_credits of this Subscription.  # noqa: E501
        :type: int
        """
        if transferred_credits is None:
            raise ValueError("Invalid value for `transferred_credits`, must not be `None`")  # noqa: E501

        self._transferred_credits = transferred_credits

    @property
    def transferred_credit_amount(self):
        """Gets the transferred_credit_amount of this Subscription.  # noqa: E501

        Summed credit amount that have been applied to invoices  # noqa: E501

        :return: The transferred_credit_amount of this Subscription.  # noqa: E501
        :rtype: int
        """
        return self._transferred_credit_amount

    @transferred_credit_amount.setter
    def transferred_credit_amount(self, transferred_credit_amount):
        """Sets the transferred_credit_amount of this Subscription.

        Summed credit amount that have been applied to invoices  # noqa: E501

        :param transferred_credit_amount: The transferred_credit_amount of this Subscription.  # noqa: E501
        :type: int
        """
        if transferred_credit_amount is None:
            raise ValueError("Invalid value for `transferred_credit_amount`, must not be `None`")  # noqa: E501

        self._transferred_credit_amount = transferred_credit_amount

    @property
    def hosted_page_links(self):
        """Gets the hosted_page_links of this Subscription.  # noqa: E501

        Links to hosted pages relating to subscription  # noqa: E501

        :return: The hosted_page_links of this Subscription.  # noqa: E501
        :rtype: SubscriptionLinks
        """
        return self._hosted_page_links

    @hosted_page_links.setter
    def hosted_page_links(self, hosted_page_links):
        """Sets the hosted_page_links of this Subscription.

        Links to hosted pages relating to subscription  # noqa: E501

        :param hosted_page_links: The hosted_page_links of this Subscription.  # noqa: E501
        :type: SubscriptionLinks
        """
        if hosted_page_links is None:
            raise ValueError("Invalid value for `hosted_page_links`, must not be `None`")  # noqa: E501

        self._hosted_page_links = hosted_page_links

    @property
    def subscription_discounts(self):
        """Gets the subscription_discounts of this Subscription.  # noqa: E501

        List of subscription discounts handles attached to subscription  # noqa: E501

        :return: The subscription_discounts of this Subscription.  # noqa: E501
        :rtype: list[str]
        """
        return self._subscription_discounts

    @subscription_discounts.setter
    def subscription_discounts(self, subscription_discounts):
        """Sets the subscription_discounts of this Subscription.

        List of subscription discounts handles attached to subscription  # noqa: E501

        :param subscription_discounts: The subscription_discounts of this Subscription.  # noqa: E501
        :type: list[str]
        """

        self._subscription_discounts = subscription_discounts

    @property
    def pending_change(self):
        """Gets the pending_change of this Subscription.  # noqa: E501

        Pending subscription change to be applied at next renewal  # noqa: E501

        :return: The pending_change of this Subscription.  # noqa: E501
        :rtype: SubscriptionChange
        """
        return self._pending_change

    @pending_change.setter
    def pending_change(self, pending_change):
        """Sets the pending_change of this Subscription.

        Pending subscription change to be applied at next renewal  # noqa: E501

        :param pending_change: The pending_change of this Subscription.  # noqa: E501
        :type: SubscriptionChange
        """

        self._pending_change = pending_change

    @property
    def subscription_changes(self):
        """Gets the subscription_changes of this Subscription.  # noqa: E501

        List of subscription changes both at most one pending and previously applied  # noqa: E501

        :return: The subscription_changes of this Subscription.  # noqa: E501
        :rtype: list[SubscriptionChange]
        """
        return self._subscription_changes

    @subscription_changes.setter
    def subscription_changes(self, subscription_changes):
        """Sets the subscription_changes of this Subscription.

        List of subscription changes both at most one pending and previously applied  # noqa: E501

        :param subscription_changes: The subscription_changes of this Subscription.  # noqa: E501
        :type: list[SubscriptionChange]
        """

        self._subscription_changes = subscription_changes

    @property
    def subscription_add_ons(self):
        """Gets the subscription_add_ons of this Subscription.  # noqa: E501

        List of subscription add-on handles attached to subscription  # noqa: E501

        :return: The subscription_add_ons of this Subscription.  # noqa: E501
        :rtype: list[str]
        """
        return self._subscription_add_ons

    @subscription_add_ons.setter
    def subscription_add_ons(self, subscription_add_ons):
        """Sets the subscription_add_ons of this Subscription.

        List of subscription add-on handles attached to subscription  # noqa: E501

        :param subscription_add_ons: The subscription_add_ons of this Subscription.  # noqa: E501
        :type: list[str]
        """

        self._subscription_add_ons = subscription_add_ons

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Subscription, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Subscription):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
