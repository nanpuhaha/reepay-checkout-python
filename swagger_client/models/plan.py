# coding: utf-8

"""
    Reepay Checkout API

    Reepay Checkout REST API  # noqa: E501

    OpenAPI spec version: 1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class Plan(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'name': 'str',
        'description': 'str',
        'vat': 'float',
        'amount': 'int',
        'quantity': 'int',
        'prepaid': 'bool',
        'handle': 'str',
        'version': 'int',
        'state': 'str',
        'currency': 'str',
        'created': 'datetime',
        'dunning_plan': 'str',
        'renewal_reminder_email_days': 'int',
        'trial_reminder_email_days': 'int',
        'partial_period_handling': 'str',
        'include_zero_amount': 'bool',
        'setup_fee': 'int',
        'setup_fee_text': 'str',
        'setup_fee_handling': 'str',
        'amount_incl_vat': 'bool',
        'fixed_count': 'int',
        'fixed_life_time_unit': 'str',
        'fixed_life_time_length': 'int',
        'trial_interval_unit': 'str',
        'trial_interval_length': 'int',
        'interval_length': 'int',
        'schedule_type': 'str',
        'schedule_fixed_day': 'int',
        'base_month': 'int',
        'notice_periods': 'int',
        'notice_periods_after_current': 'bool',
        'fixation_periods': 'int',
        'fixation_periods_full': 'bool'
    }

    attribute_map = {
        'name': 'name',
        'description': 'description',
        'vat': 'vat',
        'amount': 'amount',
        'quantity': 'quantity',
        'prepaid': 'prepaid',
        'handle': 'handle',
        'version': 'version',
        'state': 'state',
        'currency': 'currency',
        'created': 'created',
        'dunning_plan': 'dunning_plan',
        'renewal_reminder_email_days': 'renewal_reminder_email_days',
        'trial_reminder_email_days': 'trial_reminder_email_days',
        'partial_period_handling': 'partial_period_handling',
        'include_zero_amount': 'include_zero_amount',
        'setup_fee': 'setup_fee',
        'setup_fee_text': 'setup_fee_text',
        'setup_fee_handling': 'setup_fee_handling',
        'amount_incl_vat': 'amount_incl_vat',
        'fixed_count': 'fixed_count',
        'fixed_life_time_unit': 'fixed_life_time_unit',
        'fixed_life_time_length': 'fixed_life_time_length',
        'trial_interval_unit': 'trial_interval_unit',
        'trial_interval_length': 'trial_interval_length',
        'interval_length': 'interval_length',
        'schedule_type': 'schedule_type',
        'schedule_fixed_day': 'schedule_fixed_day',
        'base_month': 'base_month',
        'notice_periods': 'notice_periods',
        'notice_periods_after_current': 'notice_periods_after_current',
        'fixation_periods': 'fixation_periods',
        'fixation_periods_full': 'fixation_periods_full'
    }

    def __init__(self, name=None, description=None, vat=None, amount=None, quantity=None, prepaid=None, handle=None, version=None, state=None, currency=None, created=None, dunning_plan=None, renewal_reminder_email_days=None, trial_reminder_email_days=None, partial_period_handling=None, include_zero_amount=None, setup_fee=None, setup_fee_text=None, setup_fee_handling=None, amount_incl_vat=None, fixed_count=None, fixed_life_time_unit=None, fixed_life_time_length=None, trial_interval_unit=None, trial_interval_length=None, interval_length=None, schedule_type=None, schedule_fixed_day=None, base_month=None, notice_periods=None, notice_periods_after_current=None, fixation_periods=None, fixation_periods_full=None):  # noqa: E501
        """Plan - a model defined in Swagger"""  # noqa: E501

        self._name = None
        self._description = None
        self._vat = None
        self._amount = None
        self._quantity = None
        self._prepaid = None
        self._handle = None
        self._version = None
        self._state = None
        self._currency = None
        self._created = None
        self._dunning_plan = None
        self._renewal_reminder_email_days = None
        self._trial_reminder_email_days = None
        self._partial_period_handling = None
        self._include_zero_amount = None
        self._setup_fee = None
        self._setup_fee_text = None
        self._setup_fee_handling = None
        self._amount_incl_vat = None
        self._fixed_count = None
        self._fixed_life_time_unit = None
        self._fixed_life_time_length = None
        self._trial_interval_unit = None
        self._trial_interval_length = None
        self._interval_length = None
        self._schedule_type = None
        self._schedule_fixed_day = None
        self._base_month = None
        self._notice_periods = None
        self._notice_periods_after_current = None
        self._fixation_periods = None
        self._fixation_periods_full = None
        self.discriminator = None

        self.name = name
        if description is not None:
            self.description = description
        if vat is not None:
            self.vat = vat
        self.amount = amount
        if quantity is not None:
            self.quantity = quantity
        if prepaid is not None:
            self.prepaid = prepaid
        self.handle = handle
        self.version = version
        self.state = state
        self.currency = currency
        self.created = created
        if dunning_plan is not None:
            self.dunning_plan = dunning_plan
        if renewal_reminder_email_days is not None:
            self.renewal_reminder_email_days = renewal_reminder_email_days
        if trial_reminder_email_days is not None:
            self.trial_reminder_email_days = trial_reminder_email_days
        if partial_period_handling is not None:
            self.partial_period_handling = partial_period_handling
        if include_zero_amount is not None:
            self.include_zero_amount = include_zero_amount
        if setup_fee is not None:
            self.setup_fee = setup_fee
        if setup_fee_text is not None:
            self.setup_fee_text = setup_fee_text
        if setup_fee_handling is not None:
            self.setup_fee_handling = setup_fee_handling
        if amount_incl_vat is not None:
            self.amount_incl_vat = amount_incl_vat
        if fixed_count is not None:
            self.fixed_count = fixed_count
        if fixed_life_time_unit is not None:
            self.fixed_life_time_unit = fixed_life_time_unit
        if fixed_life_time_length is not None:
            self.fixed_life_time_length = fixed_life_time_length
        if trial_interval_unit is not None:
            self.trial_interval_unit = trial_interval_unit
        if trial_interval_length is not None:
            self.trial_interval_length = trial_interval_length
        self.interval_length = interval_length
        self.schedule_type = schedule_type
        if schedule_fixed_day is not None:
            self.schedule_fixed_day = schedule_fixed_day
        if base_month is not None:
            self.base_month = base_month
        if notice_periods is not None:
            self.notice_periods = notice_periods
        if notice_periods_after_current is not None:
            self.notice_periods_after_current = notice_periods_after_current
        if fixation_periods is not None:
            self.fixation_periods = fixation_periods
        if fixation_periods_full is not None:
            self.fixation_periods_full = fixation_periods_full

    @property
    def name(self):
        """Gets the name of this Plan.  # noqa: E501

        Name of the plan  # noqa: E501

        :return: The name of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this Plan.

        Name of the plan  # noqa: E501

        :param name: The name of this Plan.  # noqa: E501
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501

        self._name = name

    @property
    def description(self):
        """Gets the description of this Plan.  # noqa: E501

        Description of the plan  # noqa: E501

        :return: The description of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this Plan.

        Description of the plan  # noqa: E501

        :param description: The description of this Plan.  # noqa: E501
        :type: str
        """

        self._description = description

    @property
    def vat(self):
        """Gets the vat of this Plan.  # noqa: E501

        Optional vat for this plan. Account default is used if none given.  # noqa: E501

        :return: The vat of this Plan.  # noqa: E501
        :rtype: float
        """
        return self._vat

    @vat.setter
    def vat(self, vat):
        """Sets the vat of this Plan.

        Optional vat for this plan. Account default is used if none given.  # noqa: E501

        :param vat: The vat of this Plan.  # noqa: E501
        :type: float
        """
        if vat is not None and vat > 1:  # noqa: E501
            raise ValueError("Invalid value for `vat`, must be a value less than or equal to `1`")  # noqa: E501
        if vat is not None and vat < 0:  # noqa: E501
            raise ValueError("Invalid value for `vat`, must be a value greater than or equal to `0`")  # noqa: E501

        self._vat = vat

    @property
    def amount(self):
        """Gets the amount of this Plan.  # noqa: E501

        Amount for the plan in the smallest unit for the account currency  # noqa: E501

        :return: The amount of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._amount

    @amount.setter
    def amount(self, amount):
        """Sets the amount of this Plan.

        Amount for the plan in the smallest unit for the account currency  # noqa: E501

        :param amount: The amount of this Plan.  # noqa: E501
        :type: int
        """
        if amount is None:
            raise ValueError("Invalid value for `amount`, must not be `None`")  # noqa: E501
        if amount is not None and amount < 0:  # noqa: E501
            raise ValueError("Invalid value for `amount`, must be a value greater than or equal to `0`")  # noqa: E501

        self._amount = amount

    @property
    def quantity(self):
        """Gets the quantity of this Plan.  # noqa: E501

        Optional default quantity of the subscription plan product for new subscriptions. Default is 1.  # noqa: E501

        :return: The quantity of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._quantity

    @quantity.setter
    def quantity(self, quantity):
        """Sets the quantity of this Plan.

        Optional default quantity of the subscription plan product for new subscriptions. Default is 1.  # noqa: E501

        :param quantity: The quantity of this Plan.  # noqa: E501
        :type: int
        """
        if quantity is not None and quantity < 1:  # noqa: E501
            raise ValueError("Invalid value for `quantity`, must be a value greater than or equal to `1`")  # noqa: E501

        self._quantity = quantity

    @property
    def prepaid(self):
        """Gets the prepaid of this Plan.  # noqa: E501

        Subscriptions can either be prepaid where an amount is paid in advance, or the opposite. This setting only relates to handling of pause scenarios.  # noqa: E501

        :return: The prepaid of this Plan.  # noqa: E501
        :rtype: bool
        """
        return self._prepaid

    @prepaid.setter
    def prepaid(self, prepaid):
        """Sets the prepaid of this Plan.

        Subscriptions can either be prepaid where an amount is paid in advance, or the opposite. This setting only relates to handling of pause scenarios.  # noqa: E501

        :param prepaid: The prepaid of this Plan.  # noqa: E501
        :type: bool
        """

        self._prepaid = prepaid

    @property
    def handle(self):
        """Gets the handle of this Plan.  # noqa: E501

        Per account unique handle for the subscription plan. Max length 255 with allowable characters [a-zA-Z0-9_.-@].  # noqa: E501

        :return: The handle of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._handle

    @handle.setter
    def handle(self, handle):
        """Sets the handle of this Plan.

        Per account unique handle for the subscription plan. Max length 255 with allowable characters [a-zA-Z0-9_.-@].  # noqa: E501

        :param handle: The handle of this Plan.  # noqa: E501
        :type: str
        """
        if handle is None:
            raise ValueError("Invalid value for `handle`, must not be `None`")  # noqa: E501

        self._handle = handle

    @property
    def version(self):
        """Gets the version of this Plan.  # noqa: E501

        Plan version  # noqa: E501

        :return: The version of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._version

    @version.setter
    def version(self, version):
        """Sets the version of this Plan.

        Plan version  # noqa: E501

        :param version: The version of this Plan.  # noqa: E501
        :type: int
        """
        if version is None:
            raise ValueError("Invalid value for `version`, must not be `None`")  # noqa: E501
        if version is not None and version < 1:  # noqa: E501
            raise ValueError("Invalid value for `version`, must be a value greater than or equal to `1`")  # noqa: E501

        self._version = version

    @property
    def state(self):
        """Gets the state of this Plan.  # noqa: E501

        State of the subscription plan one of the following: `active`, `superseded`, `deleted`  # noqa: E501

        :return: The state of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this Plan.

        State of the subscription plan one of the following: `active`, `superseded`, `deleted`  # noqa: E501

        :param state: The state of this Plan.  # noqa: E501
        :type: str
        """
        if state is None:
            raise ValueError("Invalid value for `state`, must not be `None`")  # noqa: E501
        allowed_values = ["active", "superseded", "deleted"]  # noqa: E501
        if state not in allowed_values:
            raise ValueError(
                "Invalid value for `state` ({0}), must be one of {1}"  # noqa: E501
                .format(state, allowed_values)
            )

        self._state = state

    @property
    def currency(self):
        """Gets the currency of this Plan.  # noqa: E501

        Currency for the subscription plan in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code  # noqa: E501

        :return: The currency of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._currency

    @currency.setter
    def currency(self, currency):
        """Sets the currency of this Plan.

        Currency for the subscription plan in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code  # noqa: E501

        :param currency: The currency of this Plan.  # noqa: E501
        :type: str
        """
        if currency is None:
            raise ValueError("Invalid value for `currency`, must not be `None`")  # noqa: E501

        self._currency = currency

    @property
    def created(self):
        """Gets the created of this Plan.  # noqa: E501

        Date when the subscripton plan was created. In ISO-8601 extended offset date-time format.  # noqa: E501

        :return: The created of this Plan.  # noqa: E501
        :rtype: datetime
        """
        return self._created

    @created.setter
    def created(self, created):
        """Sets the created of this Plan.

        Date when the subscripton plan was created. In ISO-8601 extended offset date-time format.  # noqa: E501

        :param created: The created of this Plan.  # noqa: E501
        :type: datetime
        """
        if created is None:
            raise ValueError("Invalid value for `created`, must not be `None`")  # noqa: E501

        self._created = created

    @property
    def dunning_plan(self):
        """Gets the dunning_plan of this Plan.  # noqa: E501

        Dunning plan handle  # noqa: E501

        :return: The dunning_plan of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._dunning_plan

    @dunning_plan.setter
    def dunning_plan(self, dunning_plan):
        """Sets the dunning_plan of this Plan.

        Dunning plan handle  # noqa: E501

        :param dunning_plan: The dunning_plan of this Plan.  # noqa: E501
        :type: str
        """

        self._dunning_plan = dunning_plan

    @property
    def renewal_reminder_email_days(self):
        """Gets the renewal_reminder_email_days of this Plan.  # noqa: E501

        Optional renewal reminder email settings. Number of days before next billing to send a reminder email.  # noqa: E501

        :return: The renewal_reminder_email_days of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._renewal_reminder_email_days

    @renewal_reminder_email_days.setter
    def renewal_reminder_email_days(self, renewal_reminder_email_days):
        """Sets the renewal_reminder_email_days of this Plan.

        Optional renewal reminder email settings. Number of days before next billing to send a reminder email.  # noqa: E501

        :param renewal_reminder_email_days: The renewal_reminder_email_days of this Plan.  # noqa: E501
        :type: int
        """
        if renewal_reminder_email_days is not None and renewal_reminder_email_days < 1:  # noqa: E501
            raise ValueError("Invalid value for `renewal_reminder_email_days`, must be a value greater than or equal to `1`")  # noqa: E501

        self._renewal_reminder_email_days = renewal_reminder_email_days

    @property
    def trial_reminder_email_days(self):
        """Gets the trial_reminder_email_days of this Plan.  # noqa: E501

        Optional end of trial reminder email settings. Number of days before end of trial to send a reminder email.  # noqa: E501

        :return: The trial_reminder_email_days of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._trial_reminder_email_days

    @trial_reminder_email_days.setter
    def trial_reminder_email_days(self, trial_reminder_email_days):
        """Sets the trial_reminder_email_days of this Plan.

        Optional end of trial reminder email settings. Number of days before end of trial to send a reminder email.  # noqa: E501

        :param trial_reminder_email_days: The trial_reminder_email_days of this Plan.  # noqa: E501
        :type: int
        """
        if trial_reminder_email_days is not None and trial_reminder_email_days < 1:  # noqa: E501
            raise ValueError("Invalid value for `trial_reminder_email_days`, must be a value greater than or equal to `1`")  # noqa: E501

        self._trial_reminder_email_days = trial_reminder_email_days

    @property
    def partial_period_handling(self):
        """Gets the partial_period_handling of this Plan.  # noqa: E501

        How to handle a potential initial partial billing period for fixed day scheduling. The options are to bill for a full period, bill prorated for the partial period, bill a zero amoumt, or not to consider the period before first fixed day a billing period. The default is to bill prorated. Options: `bill_full`, `bill_prorated`, `bill_zero_amount`, `no_bill`.  # noqa: E501

        :return: The partial_period_handling of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._partial_period_handling

    @partial_period_handling.setter
    def partial_period_handling(self, partial_period_handling):
        """Sets the partial_period_handling of this Plan.

        How to handle a potential initial partial billing period for fixed day scheduling. The options are to bill for a full period, bill prorated for the partial period, bill a zero amoumt, or not to consider the period before first fixed day a billing period. The default is to bill prorated. Options: `bill_full`, `bill_prorated`, `bill_zero_amount`, `no_bill`.  # noqa: E501

        :param partial_period_handling: The partial_period_handling of this Plan.  # noqa: E501
        :type: str
        """
        allowed_values = ["bill_full", "bill_prorated", "bill_zero_amount", "no_bill"]  # noqa: E501
        if partial_period_handling not in allowed_values:
            raise ValueError(
                "Invalid value for `partial_period_handling` ({0}), must be one of {1}"  # noqa: E501
                .format(partial_period_handling, allowed_values)
            )

        self._partial_period_handling = partial_period_handling

    @property
    def include_zero_amount(self):
        """Gets the include_zero_amount of this Plan.  # noqa: E501

        Whether to add a zero amount order line to subscription invoices if plan amount is zero or the subscription overrides to zero amount. The default is to not include the line. If no other order lines are present the plan order line will be added.  # noqa: E501

        :return: The include_zero_amount of this Plan.  # noqa: E501
        :rtype: bool
        """
        return self._include_zero_amount

    @include_zero_amount.setter
    def include_zero_amount(self, include_zero_amount):
        """Sets the include_zero_amount of this Plan.

        Whether to add a zero amount order line to subscription invoices if plan amount is zero or the subscription overrides to zero amount. The default is to not include the line. If no other order lines are present the plan order line will be added.  # noqa: E501

        :param include_zero_amount: The include_zero_amount of this Plan.  # noqa: E501
        :type: bool
        """

        self._include_zero_amount = include_zero_amount

    @property
    def setup_fee(self):
        """Gets the setup_fee of this Plan.  # noqa: E501

        Optional one-time setup fee billed with the first invoice or as a separate invoice depending on the setting `setup_fee_handling`.  # noqa: E501

        :return: The setup_fee of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._setup_fee

    @setup_fee.setter
    def setup_fee(self, setup_fee):
        """Sets the setup_fee of this Plan.

        Optional one-time setup fee billed with the first invoice or as a separate invoice depending on the setting `setup_fee_handling`.  # noqa: E501

        :param setup_fee: The setup_fee of this Plan.  # noqa: E501
        :type: int
        """
        if setup_fee is not None and setup_fee < 0:  # noqa: E501
            raise ValueError("Invalid value for `setup_fee`, must be a value greater than or equal to `0`")  # noqa: E501

        self._setup_fee = setup_fee

    @property
    def setup_fee_text(self):
        """Gets the setup_fee_text of this Plan.  # noqa: E501

        Optional invoice order text for the setup fee that  # noqa: E501

        :return: The setup_fee_text of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._setup_fee_text

    @setup_fee_text.setter
    def setup_fee_text(self, setup_fee_text):
        """Sets the setup_fee_text of this Plan.

        Optional invoice order text for the setup fee that  # noqa: E501

        :param setup_fee_text: The setup_fee_text of this Plan.  # noqa: E501
        :type: str
        """

        self._setup_fee_text = setup_fee_text

    @property
    def setup_fee_handling(self):
        """Gets the setup_fee_handling of this Plan.  # noqa: E501

        How the billing of the setup fee should be done. The options are: `first` - include setup fee as order line on the first scheduled invoice. `separate` - create a separate invoice for the setup fee, is appropriate if first invoice is not in conjunction with creation. `separate_conditional` - create a separate invoice for setup fee if the first invoice is not created in conjunction with the creation. Default is `first`.  # noqa: E501

        :return: The setup_fee_handling of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._setup_fee_handling

    @setup_fee_handling.setter
    def setup_fee_handling(self, setup_fee_handling):
        """Sets the setup_fee_handling of this Plan.

        How the billing of the setup fee should be done. The options are: `first` - include setup fee as order line on the first scheduled invoice. `separate` - create a separate invoice for the setup fee, is appropriate if first invoice is not in conjunction with creation. `separate_conditional` - create a separate invoice for setup fee if the first invoice is not created in conjunction with the creation. Default is `first`.  # noqa: E501

        :param setup_fee_handling: The setup_fee_handling of this Plan.  # noqa: E501
        :type: str
        """

        self._setup_fee_handling = setup_fee_handling

    @property
    def amount_incl_vat(self):
        """Gets the amount_incl_vat of this Plan.  # noqa: E501

        Whether the amount is including VAT. Default true.  # noqa: E501

        :return: The amount_incl_vat of this Plan.  # noqa: E501
        :rtype: bool
        """
        return self._amount_incl_vat

    @amount_incl_vat.setter
    def amount_incl_vat(self, amount_incl_vat):
        """Sets the amount_incl_vat of this Plan.

        Whether the amount is including VAT. Default true.  # noqa: E501

        :param amount_incl_vat: The amount_incl_vat of this Plan.  # noqa: E501
        :type: bool
        """

        self._amount_incl_vat = amount_incl_vat

    @property
    def fixed_count(self):
        """Gets the fixed_count of this Plan.  # noqa: E501

        Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices.  # noqa: E501

        :return: The fixed_count of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._fixed_count

    @fixed_count.setter
    def fixed_count(self, fixed_count):
        """Sets the fixed_count of this Plan.

        Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices.  # noqa: E501

        :param fixed_count: The fixed_count of this Plan.  # noqa: E501
        :type: int
        """
        if fixed_count is not None and fixed_count < 1:  # noqa: E501
            raise ValueError("Invalid value for `fixed_count`, must be a value greater than or equal to `1`")  # noqa: E501

        self._fixed_count = fixed_count

    @property
    def fixed_life_time_unit(self):
        """Gets the fixed_life_time_unit of this Plan.  # noqa: E501

        Time unit use for fixed life time  # noqa: E501

        :return: The fixed_life_time_unit of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._fixed_life_time_unit

    @fixed_life_time_unit.setter
    def fixed_life_time_unit(self, fixed_life_time_unit):
        """Sets the fixed_life_time_unit of this Plan.

        Time unit use for fixed life time  # noqa: E501

        :param fixed_life_time_unit: The fixed_life_time_unit of this Plan.  # noqa: E501
        :type: str
        """
        allowed_values = ["months", "days"]  # noqa: E501
        if fixed_life_time_unit not in allowed_values:
            raise ValueError(
                "Invalid value for `fixed_life_time_unit` ({0}), must be one of {1}"  # noqa: E501
                .format(fixed_life_time_unit, allowed_values)
            )

        self._fixed_life_time_unit = fixed_life_time_unit

    @property
    def fixed_life_time_length(self):
        """Gets the fixed_life_time_length of this Plan.  # noqa: E501

        Fixed life time length for subscriptions using this plan. E.g. 12 months. Subscriptions will cancel after the fixed life time and expire when the active billing cycle ends.  # noqa: E501

        :return: The fixed_life_time_length of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._fixed_life_time_length

    @fixed_life_time_length.setter
    def fixed_life_time_length(self, fixed_life_time_length):
        """Sets the fixed_life_time_length of this Plan.

        Fixed life time length for subscriptions using this plan. E.g. 12 months. Subscriptions will cancel after the fixed life time and expire when the active billing cycle ends.  # noqa: E501

        :param fixed_life_time_length: The fixed_life_time_length of this Plan.  # noqa: E501
        :type: int
        """
        if fixed_life_time_length is not None and fixed_life_time_length < 1:  # noqa: E501
            raise ValueError("Invalid value for `fixed_life_time_length`, must be a value greater than or equal to `1`")  # noqa: E501

        self._fixed_life_time_length = fixed_life_time_length

    @property
    def trial_interval_unit(self):
        """Gets the trial_interval_unit of this Plan.  # noqa: E501

        Time unit for free trial period  # noqa: E501

        :return: The trial_interval_unit of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._trial_interval_unit

    @trial_interval_unit.setter
    def trial_interval_unit(self, trial_interval_unit):
        """Sets the trial_interval_unit of this Plan.

        Time unit for free trial period  # noqa: E501

        :param trial_interval_unit: The trial_interval_unit of this Plan.  # noqa: E501
        :type: str
        """
        allowed_values = ["months", "days"]  # noqa: E501
        if trial_interval_unit not in allowed_values:
            raise ValueError(
                "Invalid value for `trial_interval_unit` ({0}), must be one of {1}"  # noqa: E501
                .format(trial_interval_unit, allowed_values)
            )

        self._trial_interval_unit = trial_interval_unit

    @property
    def trial_interval_length(self):
        """Gets the trial_interval_length of this Plan.  # noqa: E501

        Free trial interval length. E.g. 1 month.  # noqa: E501

        :return: The trial_interval_length of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._trial_interval_length

    @trial_interval_length.setter
    def trial_interval_length(self, trial_interval_length):
        """Sets the trial_interval_length of this Plan.

        Free trial interval length. E.g. 1 month.  # noqa: E501

        :param trial_interval_length: The trial_interval_length of this Plan.  # noqa: E501
        :type: int
        """
        if trial_interval_length is not None and trial_interval_length < 1:  # noqa: E501
            raise ValueError("Invalid value for `trial_interval_length`, must be a value greater than or equal to `1`")  # noqa: E501

        self._trial_interval_length = trial_interval_length

    @property
    def interval_length(self):
        """Gets the interval_length of this Plan.  # noqa: E501

        The length of intervals. E.g. every second month or every 14 days.  # noqa: E501

        :return: The interval_length of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._interval_length

    @interval_length.setter
    def interval_length(self, interval_length):
        """Sets the interval_length of this Plan.

        The length of intervals. E.g. every second month or every 14 days.  # noqa: E501

        :param interval_length: The interval_length of this Plan.  # noqa: E501
        :type: int
        """
        if interval_length is None:
            raise ValueError("Invalid value for `interval_length`, must not be `None`")  # noqa: E501
        if interval_length is not None and interval_length < 1:  # noqa: E501
            raise ValueError("Invalid value for `interval_length`, must be a value greater than or equal to `1`")  # noqa: E501

        self._interval_length = interval_length

    @property
    def schedule_type(self):
        """Gets the schedule_type of this Plan.  # noqa: E501

        Scheduling type, one of the following: `manual`, `daily`, `weekly_fixedday`, `month_startdate`, `month_fixedday`, `month_lastday`. See documentation for descriptions of the different types.  # noqa: E501

        :return: The schedule_type of this Plan.  # noqa: E501
        :rtype: str
        """
        return self._schedule_type

    @schedule_type.setter
    def schedule_type(self, schedule_type):
        """Sets the schedule_type of this Plan.

        Scheduling type, one of the following: `manual`, `daily`, `weekly_fixedday`, `month_startdate`, `month_fixedday`, `month_lastday`. See documentation for descriptions of the different types.  # noqa: E501

        :param schedule_type: The schedule_type of this Plan.  # noqa: E501
        :type: str
        """
        if schedule_type is None:
            raise ValueError("Invalid value for `schedule_type`, must not be `None`")  # noqa: E501
        allowed_values = ["manual", "daily", "weekly_fixedday", "month_startdate", "month_fixedday", "month_lastday"]  # noqa: E501
        if schedule_type not in allowed_values:
            raise ValueError(
                "Invalid value for `schedule_type` ({0}), must be one of {1}"  # noqa: E501
                .format(schedule_type, allowed_values)
            )

        self._schedule_type = schedule_type

    @property
    def schedule_fixed_day(self):
        """Gets the schedule_fixed_day of this Plan.  # noqa: E501

        If a fixed day scheduling type is used a fixed day must be provided. For months the allowed value is 1-28 for weeks it is 1-7  # noqa: E501

        :return: The schedule_fixed_day of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._schedule_fixed_day

    @schedule_fixed_day.setter
    def schedule_fixed_day(self, schedule_fixed_day):
        """Sets the schedule_fixed_day of this Plan.

        If a fixed day scheduling type is used a fixed day must be provided. For months the allowed value is 1-28 for weeks it is 1-7  # noqa: E501

        :param schedule_fixed_day: The schedule_fixed_day of this Plan.  # noqa: E501
        :type: int
        """
        if schedule_fixed_day is not None and schedule_fixed_day > 28:  # noqa: E501
            raise ValueError("Invalid value for `schedule_fixed_day`, must be a value less than or equal to `28`")  # noqa: E501
        if schedule_fixed_day is not None and schedule_fixed_day < 1:  # noqa: E501
            raise ValueError("Invalid value for `schedule_fixed_day`, must be a value greater than or equal to `1`")  # noqa: E501

        self._schedule_fixed_day = schedule_fixed_day

    @property
    def base_month(self):
        """Gets the base_month of this Plan.  # noqa: E501

        For fixed month schedule types the base month can be used to control which months are eligible for start of first billing period. The eligible months are calculated as `base_month + k * interval_length` up to 12. E.g. to use quaterly billing in the months jan-apr-jul-oct, `base_month` 1 and `interval_length` 3 can be used. If not defined the first fixed day will be used as start of first billing period.  # noqa: E501

        :return: The base_month of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._base_month

    @base_month.setter
    def base_month(self, base_month):
        """Sets the base_month of this Plan.

        For fixed month schedule types the base month can be used to control which months are eligible for start of first billing period. The eligible months are calculated as `base_month + k * interval_length` up to 12. E.g. to use quaterly billing in the months jan-apr-jul-oct, `base_month` 1 and `interval_length` 3 can be used. If not defined the first fixed day will be used as start of first billing period.  # noqa: E501

        :param base_month: The base_month of this Plan.  # noqa: E501
        :type: int
        """
        if base_month is not None and base_month > 12:  # noqa: E501
            raise ValueError("Invalid value for `base_month`, must be a value less than or equal to `12`")  # noqa: E501
        if base_month is not None and base_month < 1:  # noqa: E501
            raise ValueError("Invalid value for `base_month`, must be a value greater than or equal to `1`")  # noqa: E501

        self._base_month = base_month

    @property
    def notice_periods(self):
        """Gets the notice_periods of this Plan.  # noqa: E501

        Optional number of notice periods for a cancel. The subscription will be cancelled for this number of full periods before expiring. Either from the cancellation date, or from the end of the the current period. See `notice_periods_after_current`. The default is to expire at the end of current period (0). A value of 1 (and `notice_periods_after_current` set to true) will for example result in a scenario where the subscription is cancelled until the end of current period, and then for the full subsequent period before expiring.  # noqa: E501

        :return: The notice_periods of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._notice_periods

    @notice_periods.setter
    def notice_periods(self, notice_periods):
        """Sets the notice_periods of this Plan.

        Optional number of notice periods for a cancel. The subscription will be cancelled for this number of full periods before expiring. Either from the cancellation date, or from the end of the the current period. See `notice_periods_after_current`. The default is to expire at the end of current period (0). A value of 1 (and `notice_periods_after_current` set to true) will for example result in a scenario where the subscription is cancelled until the end of current period, and then for the full subsequent period before expiring.  # noqa: E501

        :param notice_periods: The notice_periods of this Plan.  # noqa: E501
        :type: int
        """
        if notice_periods is not None and notice_periods < 0:  # noqa: E501
            raise ValueError("Invalid value for `notice_periods`, must be a value greater than or equal to `0`")  # noqa: E501

        self._notice_periods = notice_periods

    @property
    def notice_periods_after_current(self):
        """Gets the notice_periods_after_current of this Plan.  # noqa: E501

        If notice periods is set, this option controls whether the number of full notice periods should start at the end of the current period, or run from cancellation date and result in a partial period with partial amount for the last period. The default is true. E.g. if set to false and `notice_periods = 1` then the subscription will be cancelled for exactly for one period from the cancellation time and a partial amount will be billed at the start of the next billing period.  # noqa: E501

        :return: The notice_periods_after_current of this Plan.  # noqa: E501
        :rtype: bool
        """
        return self._notice_periods_after_current

    @notice_periods_after_current.setter
    def notice_periods_after_current(self, notice_periods_after_current):
        """Sets the notice_periods_after_current of this Plan.

        If notice periods is set, this option controls whether the number of full notice periods should start at the end of the current period, or run from cancellation date and result in a partial period with partial amount for the last period. The default is true. E.g. if set to false and `notice_periods = 1` then the subscription will be cancelled for exactly for one period from the cancellation time and a partial amount will be billed at the start of the next billing period.  # noqa: E501

        :param notice_periods_after_current: The notice_periods_after_current of this Plan.  # noqa: E501
        :type: bool
        """

        self._notice_periods_after_current = notice_periods_after_current

    @property
    def fixation_periods(self):
        """Gets the fixation_periods of this Plan.  # noqa: E501

        Optional number of fixation periods. Fixation periods will guarantee that a subscription will have this number of paid full periods before expiring after a cancel. Default is to have no requirement (0).  # noqa: E501

        :return: The fixation_periods of this Plan.  # noqa: E501
        :rtype: int
        """
        return self._fixation_periods

    @fixation_periods.setter
    def fixation_periods(self, fixation_periods):
        """Sets the fixation_periods of this Plan.

        Optional number of fixation periods. Fixation periods will guarantee that a subscription will have this number of paid full periods before expiring after a cancel. Default is to have no requirement (0).  # noqa: E501

        :param fixation_periods: The fixation_periods of this Plan.  # noqa: E501
        :type: int
        """
        if fixation_periods is not None and fixation_periods < 0:  # noqa: E501
            raise ValueError("Invalid value for `fixation_periods`, must be a value greater than or equal to `0`")  # noqa: E501

        self._fixation_periods = fixation_periods

    @property
    def fixation_periods_full(self):
        """Gets the fixation_periods_full of this Plan.  # noqa: E501

        If fixation periods are defined, and the subscription can have a partial prorated first period, this parameter controls if the the last period should be full, or partial to give exactly `fixation_periods` paid periods. Default is false.  # noqa: E501

        :return: The fixation_periods_full of this Plan.  # noqa: E501
        :rtype: bool
        """
        return self._fixation_periods_full

    @fixation_periods_full.setter
    def fixation_periods_full(self, fixation_periods_full):
        """Sets the fixation_periods_full of this Plan.

        If fixation periods are defined, and the subscription can have a partial prorated first period, this parameter controls if the the last period should be full, or partial to give exactly `fixation_periods` paid periods. Default is false.  # noqa: E501

        :param fixation_periods_full: The fixation_periods_full of this Plan.  # noqa: E501
        :type: bool
        """

        self._fixation_periods_full = fixation_periods_full

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Plan, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Plan):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
